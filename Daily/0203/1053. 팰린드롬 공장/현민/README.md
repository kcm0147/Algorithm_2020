# 1053 펠린드롬 공장

## 접근법
1. 앞에서 읽은 것이 뒤에서 읽은 것과 같다는 말은 str[0] = str[size-1], str[1] = str[size-2], ... 이런식으로 중간을 기준으로 대칭이 되어야 한다.

    - 즉, 양쪽 끝에서부터 비교해도 된다는 것이다.

2. 여기서 1,2,3번째 조건을 이용하여 문자열을 수정할 때 맨 끝에서부터 적용시키면 된다.

    - 왜냐하면 중간에 적용이 되었다는 것은 맨 끝에서부터 적용해나가는 것에 중간이 적용되었다는 것을 포함하기 때문이다.

3. 1번째 컨디션의 경우 양쪽 끝 중 하나에 적용시키며, 이때 당연히 반대쪽 끝과 문자를 맞춰야하므로 어떤 문자를 추가할 것인지는 정해져있다.

    - 따라서 왼쪽 끝에 추가시켰을 경우 (left, right-1)을 확인하고, 오른 쪽 끝에 추가했을 때는 (left+1, right)을 확인하면 된다.

4. 2번째 컨디션의 경우에는 양쪽 끝 중에 하나를 지우는 것이니 (left, right-1) 또는 (left+1, right)를 확인하면 된다.

5. 3번째 조건의 경우 양쪽 중 하나를 반대쪽과 맞는 문자로 바꿧다고 볼 수 있으니 (left+1, right-1)을 확인하면 된다.

6. 최종적으로 현재 부분 문자열 (left, right)가 주어졌을 때 최소 기회비용은 다음과 같다.

    - 1 + min of (left+1, right), (left+1, right-1), (left, right-1) 

    - 단 str[left] == str[right]일 경우에는 바꿀 필요가 없으므로 (left+1, right-1)이다. 

7. 4번째 컨디션의 경우 중간에 문자를 바꿔도 상관없으나, 먼저 바꾸고 시작해도 상관없으니 먼저 바꾸고 시작한다.

8. (left, right)을 확인하는 과정에서 중복되는 부분이 많으므로 dp를 적용한다.

## 느낀 점

1. 처음 문제를 보고 겁을 먹었으나 차근차근 문제를 접근하다 보니 dp로 충분히 풀 수 있음을 알았다.
