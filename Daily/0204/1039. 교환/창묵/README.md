처음에는 그리디로 접근을 하고 문제를 해결하려고 했습니다

맨 왼쪽부터 탐색을 하나씩 시작하면서, 가장 큰 숫자와 교환을 하는 식으로

문제를 해결 하려고 했지만 반례가 존재합니다.

```
31299 2 를 예로들면, 

31299 -> 91293이 되고

91293 -> 99213이 나오는데 실제로는

31299 -> 91239 -> 99231이 답이 되어야 합니다.

```

그래서 생각 해낸 것이 다이나믹프로그래밍과 완전탐색이었는데 완전탐색을 하기에도 

수의 범위가 N은 최대 7자리 K는 10회의 연산이기때문에 충분히 가능하다고 

생각했습니다. 그래서 for문 루프를 두번돌면서 bfs를 진행 해주었습니다

여기서 가장 중요한것은 `K번연산`을 잘 생각 해야합니다.

그냥 que에서 bfs를 진행해서는 안되고 k번연산에 따라서 que에서 Poll()을
 
 하면서 연산을 진행해야합니다.

그렇게 하기 위해서 `for(q의사이즈)` 만큼 루프문을 하나 더 만들었습니다


visit 처리는 문자열을 기준으로 visit를 확인해야하기 떄문에 `Map`을 사용하였습니다