# 2092. 집합의 개수

###### 작성자 : O-star

<br/>

<br/>

## 풀이 : 

**문제 접근부터 쉽지 않아서 결국은 솔루션을 참고해서 푼 문제였다. 우선 DP를 사용해야 한다고 생각이 들고나서도 어떤 데이터를 메모이제이션해야할지 쉽게 감이 오지 않았다. 대표적인 유형들의 DP 문제들에서 벗어난 문제들을 풀어봄으로써 좀 더 유연하게 사고하는 연습이 필요한 듯 하다.**

**<br/>**

#### **[세부 구현사항]**

- **본 문제의 키포인트는 각 숫자들을 몇개씩 사용해서 만들었는지를 세는 조합 문제이라는 것이다. 그래서 나는 코드에서 cntary[] 배열을 사용하여 각 숫자들이 몇 개씩 있는지 카운트하였다.**
- **dp 메모이제이션 배열을 구성할 때의 키포인트는 바로 각 숫자들 하나만을 사용해서 만들 수 있는 조합 개수를 통해 누적합을 더해가는 방식을 사용해야 한다는 것이다. => 쉽게 말해서 한 숫자만을 사용해서 만들 수 있는 조합은 항상 그 숫자의 갯수(공집합 제외할 시)만큼 나타난다(ex. 5가 3개 있을 경우 {공집합}, {5}, {5, 5}, {5, 5, 5}) 이렇게 한 숫자만을 사용해서 만들 수 있는 조합을 그보다 작은 숫자들을 이용해 만들 수 있는 경우의 수를 누적합해주면 dp 메모이제이션을 해결할 수 있다.**
- **dp배열은 행 : 사용 숫자 범위, 열 : 집합 원소 갯수 k개 로 구성된다.**
- **`dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % DVD` => (조건, 0<k<=cntary[i])**

**처음에는 각 숫자들을 떼서 한 숫자로 만들 수 있는 조합을 붙여가며 메모이제이션할 생각을 전혀 하지 못했다. 당연히 조합 문제는 재귀 방식으로 탐색하면서 백트래킹을 활용해야할 것이라는 생각에서 벗어나지 못해 로직을 쉽게 떠올리지 못한 것 같다.**

<br/>

<br/>

#### 코드 : 

```c++
#include <iostream>

#define DVD 1000000

using namespace std;
int dp[201][4001], cntary[201];

int main() {
    int range, n, start, end, input, answer = 0;
    cin >> range >> n >> start >> end;

    for (int i = 0; i < n; i++) {
        cin >> input;
        cntary[input]++;
    }

    for (int i = 0; i <= cntary[1]; i++)
        dp[1][i] = 1;

    for (int i = 2; i <= 200; i++) {
        dp[i][0] = 1;
        for (int j = 1; j <= n; j++) {
            int cntval = cntary[i];
            for (int k = 0; k <= cntval; k++)
                if (k <= j) dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % DVD;
        }
    }

    for (int k = start; k <= end; k++)
        answer = (answer + dp[200][k]) % DVD;

    cout << answer << '\n';
    return 0;
}
```

