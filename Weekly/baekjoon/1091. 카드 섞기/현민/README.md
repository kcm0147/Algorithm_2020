# 풀이

## 문제 이해

### 입력

- 0,1,2번의 플레이어

- N : 카드 갯수

- P : 처음 i번째 위치의 카드를 Pi 플레이어에게 줘야 함

- S : 카드를 섞을 때 i번 위치의 카드가 Si로 움직임.

### 출력

- P를 만족시키기 위해, 카드를 최소한의 섞어야 하는 횟수

## 문제 해결 계획

### 해결 전략

- 단순한 방법에서 시작할 수 있을까? 를 채택

- 숫자도 크지 않고, 다음 state로 방향이 일정함(S가 고정되어 있으므로)

- 완전 탐색으로 충분히 풀 수 있다고 생각함!

### 계획 검증

```
while(!deck.finish())
    if(visited[deck]) return -1;
    deck.suffle();
```

- 시간

    - 섞다가 똑같은 덱이 나오면 더 이상 섞는게 의미없음.

    - 48!이 아님!

        - 비둘기 집의 원리에 의해 카드를 섞다보면 카드는 똑같은 지점들을 계속 방문하게 된다.

        - (cycle1의 길이) , (cycle2의 길이) , (cycleK의 길이) 의 최소공배수가 최대 시간복잡도가 된다.

        - 이는 손으로 예를 든다고 해도 충분한 시간안에 풀 수 있음이 증명된다.

- 공간

    - N이 48이므로 저장한다해도 얼마 되지 않음.

    - visited를 위해 deck을 하나씩 생성한다고 했을 때 시간 복잡도 * 48 * 4byte이다. 이것도 충분하다.

        - 실제로는 부족하였다...

## 회고

- Deck에 suffle정책과 판단정책을 주입시켜보았다.

    - 확실히 유연한 설계는 복잡함을 낳긴 하는군 그래도 에러 고칠 때 매우 쉬웠다.

- 결국 언젠가 맨 초기 상태로 간다는 사실을 인지 못하였다.

- 배열의.equals는 A == B였다... 안에 있는 걸 비교하는게 아니었다.

    - 생고생했다...

    - Arrays.equals메서드를 쓰자
