# 1938. 통나무 옮기기

정석 풀이 : 

첫번째 시도.
- 우선 문제가 길고 이동방향에 회전 방식도 존재해서 굉장히 까다로웠다. 단순히 경로탐색이라 생각하고 DFS or BFS로 접근하려 해도 쉽지 않았다. 그래서 우선 문제 접근이라도 해보자 싶어 BFS 방식으로 구현을 시작했다.
BFS 방식에서 현재 위치에서 도착 위치까지의 세 점들의 거리를 기준으로 우선순위 큐를 구현해 보려했다. 하지만 거리 순으로 우선순위 큐를 pop 할 시 최단 경로를 찾을 수 있을까 하는 의문점이 들었다.
그래서 현재까지 이동한 횟수를 level로 표시하여 level이 낮은 순으로 pop하고 경로를 찾을 시 횟수를 answer에 저장한 후 다음 pop한 노드의 level + 1이 현재 answer보다 크거나 같을 시 더이상 탐색하지 않고 답을 출력하게 만들었다.

두번째 시도.
- 많은 시간이 걸리긴 했으나 첫번째 시도로 테스트 케이스가 성공적으로 출력되었다. 하지만 백준에 채점을 해보니 바로 메모리 초과가 떳다. 그래서 그때부터 메모리를 줄일 방법을 구상해보았다. 우선 내가 구현한 priority queue에서는 통나무의 세 노드를 모두 저장했으며 방문횟수를 효과적으로 줄이지 못하고 있는 것을 깨달았다. 그래서 우선 통나무의 세 노드를 저장하는 방식이 아닌 가로(수평), 세로(수직) 방향을 저장하고 중간 좌표만을 저장하게 구현해 보았다. 그 결과 역시 메모리 초과가 뜨긴 했다.

세번째 시도.
- 전에 BFS 관련 문제를 풀 때에도 메모리 초과가 떳던 경험이 떠올랐다. 보통 BFS 문제에서는 필요없는 노드들을 과도하게 큐에 집어넣는 경우 메모리 초과가 뜨는 경우가 많았다. 때문에 처음에는 visit 여부를 따로 확인하지 않고 지나쳐 온 경로를 모두 '2' 문자로 바꾸는 방식 대신 vist 3차원 배열을 만들어 수직 통나무, 수평 통나무가 방문한 위치를 모두 기록하여 필요없는 노드들을 큐에 집어넣지 않게 구현해 보았다. 그 결과 코드는 좀 많이 길어졌지만 성공적으로 구현을 할 수 있었다.