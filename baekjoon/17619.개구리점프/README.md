# 17619. 개구리 점프

<h2>느낀점</h2>
> 반례를 계속 생각하다가 내가 만든 제약조건에 계속 걸려서 더 이상 진행을 못했었다.. 풀고나서 다시 생각해보니 허용되는 조건이었던 것이었던 것!
<hr style="color:green">

<h2>풀이</h2>
<ol type="I">
    <li>한 통나무의 끝 지점보다 다른 통나무의 시작지점이 더 작거나 같으면 무조건 겹칠 수 밖에 없음</li>
    <li>이를 위해 시작값을 기준으로 통나무들을 정렬, 원래 인덱스도 보관.</li>
    <li>이후 모든 통나무들이 이동 가능한 범주 여러 개로 나누어져 담긴다.</li>
    <li>두 통나무가 서로 이동 가능한지 따져보려면 같은 범주에 속하는지 판단하면 된다.</li>
</ol>
<hr color="green">
<h2>실수</h2>

><h4><b>첫 번째 시도</b></h4>
>각 x 좌표마다 이동 가능한 통나무의 index를 보관하는 멀티맵을 구상하여 접근하였다. 10만*10만의 시간복잡도 예상
><h4>두 번째 시도</h4>
>시간 복잡도를 줄이기 위해 x값을 기준으로 오름차순 정렬, 현재 통나무의 끝 지점과 다음 통나무의 시작지점으로 반복문 break 조건걸어 탐색횟수를 줄였다.
>하지만 두 통나무 사이에 이동이 가능한 지를 판별하는 방법으로 dfs를 구상했으나 실패.
><h4>세 번째 시도</h4>
>애초에 dfs로 들어가지 않고 현재 통나무 끝 지점, 다음 통나무 시작 지점으로 한 쌍의 통나무가 서로 이동가능한 지
>따져볼 때 그룹으로 묶으면 되는 것이었음. 2번째 시도 때 dfs 로 접근하기 전에 union-find를 잠깐 생각 했었는데
>'다른 통나무가 위에 있을 경우 그 위에 통나무로 점프 불가' 라는 조건이 있어서 고민해보다가 포기했었다.
>그러나 이러한 조건은 사실상 큰 의미가 없었던 것.. 1번 2번이 연결되면 2번 3번을 따져보고 1번과 3번이 연결
>되는지를 알 수 있었기 때문이다.. --> 즉 union-find를 사용하는 것이었다.
><h4>네 번째 시도</h4>
>union-find로 풀고 나서 질문글을 봤는데 어떤 사람이 union-find 도 필요없이 반복문 1개로 가능하다고 해서 어떻게 하는지 고민해보다가
>네이버에서 찾아봤더니 그냥 반복문으로 순회하며 이동이 가능한 group을 지어서 짜는 것을 발견했음.
> 나는 아직 멀었다는 깨달음을 얻었다..... 

