# 17619. 개구리점프

# 풀이법

1. 입력값(x1, x2, y)와 동시에 node의 번호를 할당하여 저장한다.(node는 통나무)
2. 속한 그룹을 알 수 있게 parent 배열을 생성하고 각 node num과 동일하게 할당한다.
3. node를 소팅한다.
4. union find 를 이용하여 node.num을 기준으로 같은 그룹에 속하는지 정한다.(동일 parent를 가지면 같은 그룹)
5. 같은 그룹에 속하면 1, 아니면 0을 출력한다.

# 실수 및 어려웠던 점

1. 시간초과가 뜨고 나서 도대체 어떻게 해야 시간을 줄일지 고민하는 시간이 너무 오래걸렸다. 소팅은 가장 기본적인 방법이지만 왜 소팅을 해야하는지 생각하고 이해하는 과정이 힘들었다.

# 느낀점

Comparable을 지금까지 class 소팅을 할 일이 없어서 굳이 쓰지 않았는데 이번 기회에 써봐서 익힐 수 있는 좋은 기회였다. union find를 이용하여 그룹화하는데 까지는 성공했는데 계속해서 시간초과가 발생하여 해결하느라 애를 많이 먹었다. sorting을 해서 해야 시간복잡도가 n^2이 안되고 훨씬 적게 들 수 있게 구현할 수 있다는 것을 깨닫는 것과 그러기 위해선 node.num을 따로 또 추가로 저장해서 구현하여야 해서 어려웠다.


