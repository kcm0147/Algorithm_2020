
# 16236. 아기 상어

<h2>느낀점</h2>
> 아이디어는 금방 떠올랐지만 코드를 좀 더 효율적으로 구현하려고 시간을 많이 썼다. 따져볼게 많은 BFS 였음. 최종적으로
짰는 코드는 메모리 2MB, 시간 0ms => AC<br>
 (ps.자꾸 익숙한 노래 멜로디가 푸는 내내 머리 속에 떠다녔다.)
<hr>

<h2>풀이</h2>
<ol type="I">
    <li>잡아 먹을 수 있는 물고기를 탐색한다 -> 최단경로, BFS</li>
    <li>탐색 순서는 상,좌,우,하 순으로</li>
    <li>최종 먹이 배열 중 거리, x, y 순으로 오름차순 정렬</li>
    <li>첫 번째로 구해진 먹이부터 먹는다.</li>
</ol>
<hr>
<h2>여러가지 풀이</h2>
<hr>

><h4><b>첫 번째</b></h4>
>우선순위큐로 접근. 각 크기 별로 물고기들의 좌표를 pair 형태로 보관하는 벡터배열 선언. 상어의 크기보다 작은 녀석들을 pq에 넣고 
정렬 순서는 거리, x, y순으로. 잡아먹은 물고기는 eaten[][] 로 표시. 더 이상 먹을 수 있는 먹이 x (pq.empty()) 이면 거리 합 출력 
><h4>두 번째</h4>
>pq를 사용하지 않고, BFS를 돌며 현재 크기에서 먹을 수 있는 모든 물고기를 canEat 벡터에 추가. 모든 칸을 탐색한 이후
거리, x, y 순으로 정렬을 마지막에 한 번만 수행하여 첫 번째 인덱스의 값을 반환. -> 상어의 위치와 거리 합 업데이트. 
