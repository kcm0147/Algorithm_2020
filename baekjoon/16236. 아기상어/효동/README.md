# 16236. 아기 상어

# 풀이법

1. 기본적인 큰 틀은 조건에 부합하는 가장 가까운 물고기의 위치로 bfs탐색을 이용하여 이동한 뒤, 그곳에서 다시 또 bfs를 반복하는 형식이다.
2. bfs를 위한 큐 하나, 각 횟수마다 처음 물고기를 발견한 거리까지의 bfs동안 발견한 물고기들을 넣을 우선순위 큐 하나 총 두개를 생성한다.
3. 처음 물고기를 발견하면 그까지 거리내에 있는 물고기들만 고려하면 되므로 그 범위 안까지만 bfs를 끝마칠 수 있도록 한다.
4. 이후 모인 물고기들 중 우선순위 큐를 통해 가장 윗쪽 왼쪽에 있는 물고기를 선별한다.
5. 그 물고기부터 다시 bfs 탐색을 한다.
6. 모든 물고기를 다 먹거나 더 이상 먹을 수 없으면 종료하고 움직인 시간을 출력한다.

# 실수 및 어려웠던 점

1. 반복적인 bfs를 사용하는 것은 단순히 while(true)안에 넣으면 되는데 그것을 생각해내지 못해서 많이 헤맸던 것 같다.
2. 우선순위 큐의 개념을 사용하는 문제를 처음 접해보아서 물고기들 중 어떻게 가장 윗쪽 왼쪽에 있는 것을 골라야할지 너무 막막해서 사실 인터넷을 좀 찾아보았는데 이번 기회를 통해서 어떤 식으로 구현해야하는지 알 수 있었다.

# 느낀점

'개구리 점프'에서 소팅과 관련된 문제로 어려웠는데 이번에 우선순위 큐를 사용하는 것도 같은 맥락이었던 것 같다. 이번 기회를 통해 compare함수에 대해 알 수 있는 좋은 시간이 되었다. 또, 대회 준비로 너무 바빠서 알고리즘에 소홀했던 것 같다.