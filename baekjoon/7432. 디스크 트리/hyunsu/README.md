# 1938. 통나무 옮기기

**느낀점**
>여러 시행착오를 겪으며 결국에는 해결하였다! 한이음 프로젝트를 하느라 시간이 조금 늦었지만 그래도 해가 뜨기 전에 해결할 수 있어 좋았다. 문제에 대해 알고리즘을 떠올린 후, 해당 문제풀이에 적합한지 타당성을 더 따져보고 접근해야겠다. 다음 번엔 트라이로 해결해봐야겠다.

**풀이**
<ol type="I">
    li>계층별로 map을 모아서 보관</li>
    <li>실제 디렉토리 구조와 같은 규칙으로 동일 경로상에 서로 다른 계층이라면 동일한 이름의 디렉토리도 생성 가능</li>
    <li>DFS를 통해 생성 및 출력</li>
</ol>

**실수**
>1. 단순히 이름이 중복될 수 있는 계층 구조의 트리를 생성하면 될 것이라고 생각했었다. 따라서 멀티맵 배열로 처음에 접근을 하였다. 하지만 멀티맵의 lower_bound()와 upper_bound()의 경우 key 값으로만 범위를 가져와서 다른 경로의 같은 이름의 디렉토리도 모두 포함해버렸다.
>2. map&lt;string, vector&lt;string&gt;&gt;[] 을 만들어서 height 별로 계층의 모든 디렉토리를 포함하는 방법을 사용했다. 하지만 이 방법 또한 어떤 경로 상에 있는 디렉토리인지 알 수 없었다.
>3. 2번 방법에서 보완하여 바로 직속 부모의 이름을 가지는 구조체를 map의 value로 갖도록 하였다. 따라서 바로 위 부모의 이름과 동일할 경우 추가하는 방법을 택했다. 하지만 이 또한 다른 경로 상에 같은 부모 이름, 같은 자식 이름을 가질 수 있는 문제가 존재하였다.
>4. 3번 방법에서 보완하여 현재 경로의 최상위 루트 부모의 이름도 추가한 구조체를 map의 value로 갖도록 하였다. 이렇게 될 경우 각 계층별로 구분되며, 직속 부모와 같은 경로임을 알 수 있는 최상위 부모를 지정해주었기 때문에 결코 중복되는 디렉토리가 존재하지 않을 것이라 생각하였다.. 이 단계에서 나는 멘탈이 터져버렸고, 출력초과 10번이라는 결과를 마주하였다.
>5. 4번까지 했던 방법을 모두 포기하고 최근에 공부하였던 '트라이' 자료구조에서 자식 포인터를 갖는 클래스의 아이디어를 떠올렸다. 특정 클래스에는 포인터 배열이 존재하며 추가될 데이터가 있을 때에만 추가되는 형식의 포인터를 갖는 아이디어를 차용하여 비어 있는 map&lt;string, DIR&gt; children 을 갖는 DIR 구조체를 생성하였다. map의 key값은 자동으로 오름차순 정렬이 되므로, print 시 map을 순회하면서 출력하고 재귀적으로 다음 자식들을 출력하도록 구현하였다. 이 때 파싱함수를 따로 분리하여 코드의 간결성을 확보하였다.
