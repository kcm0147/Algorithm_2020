# 1967. 트리의 지름

# 입력

n : 노드의 갯수

p, c, d : 간선의 정보(부모, 자식, 거리)

위 입력으로 트리가 주어진다(이진 트리 아님!)

# 출력

radius : 트리의 지름(트리에서 가장 긴 노드간 거리)

# How To Solve

1) 처음에 문제를 봤을 때 본적이 있었던 내용이었다. 

알고리즘 문제 해결전략에서 트리의 지름을 구하는 코드를 본 적이 있었고 최대한 구현하려 하였다.

2) radius(root) 는 max radius(child)와 루트에서 리프노드간 거리 중 제일 긴 2개를 합친 것중 더 큰 것이다.

radius(root)는 재귀적으로 호출하였으며, cache하였다.

max radius(child)와 루트에서 리프노드간 거리 중 제일 긴 2개를 합친 것보다 긴 것이 없는 것은 귀류법을 통해 간단히 증명할 수 있다.


# 느낀점

1) 찾아보니 어쨌든 트리의 지름의 끝 점 2개는 리프노드일 수밖에 없는 걸 이용해 dfs를 두 번 돌리는 코드를 보았다.

증명은 귀류법을 통해 할 수 있었다. 참신했고 좋은 방법이었다. 코드도 간단하고 좋았다.

2) Pair가 안되어 고생고생했다. 담에 할 수 있는 방법을 찾아봐야겠다.