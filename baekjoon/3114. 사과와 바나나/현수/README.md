# 3114. 사과와 바나나

<h2>느낀점</h2>
> 생각보다 커다란 배열을 여러개 잡아도 메모리 초과가 잘 뜨지 않는 것 같다. 시간을 줄이려고 메모리를 최대한 많이 썼다. DP랑 부분합을 구하는 방법이 종만북에서 공부했던 내용들이라 어렵지 않게 풀 수 있었다. 
<hr>

<h2>풀이</h2>
<ol type="I">
    <li>최적 부분 구조를 파악. 현재까지의 최적해가 subproblem의 최적 해에 영향을 끼치는지 확인하였다. -> 영향x </li>
    <li>탐색 시간을 줄이기 위해서 위쪽으로 바나나 나무의 부분합과 아래쪽으로 사과 나무의 부분합을 구했다.</li>
    <li>현재 위치를 기준으로 위쪽의 바나나 나무, 아래 쪽의 사과 나무를 구하기 위해 두 나무의 (부분합 - 현재 위치의 나무 수) 로 바꿔 생각했다.</li>
    <li>한 칸에서 최종적으로 바뀐 값은 문제의 조건에 맞는 위쪽 바나나, 아래쪽 사과나무 의 총합이 된다.</li>
    <li>이 값들로 전형적인 DP 문제로 접근하여 푼다. (최적 부분 구조OK)</li>
</ol>
<hr>

